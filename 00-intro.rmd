# 0. Introduction

*What is the purpose of this project?*
*Why should we care about it?*
*What makes this a difficult exercise?*
*What is your overall modeling strategy?*
*Briefly summarize your results.*

Boulder County - population growing, Zillow wants us adjust their pricing algorithm to reflect now growing demand for houses.  

What are some aspects of Boulder County

```{r import_libraries, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen=999)

library(tidyverse)
library(lubridate)
library(RColorBrewer)
library(patchwork)
library(scales)
library(knitr)
library(kableExtra)
library(ggplot2)
library(caret)

library(tidycensus)
library(sf)
library(sp)
library(tmap)
#library(ggrepel)
library(tigris)
library(stargazer)
library(ggcorrplot)
library(glue)
library(rvest)

mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.text.x = element_text(size = 14))
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    
    
    plot.background = element_blank(),
    
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    
    strip.text.x = element_text(size = 14)
  )
}


plot_limits = function(
  poly.geometry = boulder.cities$geometry,
  # buffer between plot's limits and the geometry 
  # (in unit of geometry column)
  buffer = 0
){
  # creates bounding box
  poly.bbox =
    poly.geometry %>% st_union() %>%
    # buffers the geometry so the ultimate plot has margins
    st_buffer(buffer) %>%
    st_bbox()
  return(
    # returns the 'coord_sf' function which you can add to any plot
    coord_sf(
      xlim = c(poly.bbox['xmin'], poly.bbox['xmax']),
      ylim = c(poly.bbox['ymin'], poly.bbox['ymax']),
      crs = st_crs(poly.geometry)
  ))}

sf_to_labels = function(
  sf_focus, label_field
){
  sf.focus.labels = 
    sf_focus %>%
    st_centroid(., of_largest_polygon = TRUE) %>% 
    mutate(
      lon = map_dbl(geometry, 
                    ~st_centroid(.x, of_largest_polygon = TRUE)[[1]]),
      lat = map_dbl(geometry, 
                    ~st_centroid(.x, of_largest_polygon = TRUE)[[2]])
    )
  
  sf.focus.labels$label = sf.focus.labels[[label_field]]
  
  #     ,
  #     size = 
  #           ifelse(grepl('city', name_long), 2,
  #                  ifelse(grepl('town', name_long), 1.5,
  #                         ifelse(grepl('CDP', name_long), 0,
  #                                0)))) %>% 
  # filter(size>0)

  return(sf.focus.labels %>% select(label, lon, lat))
}

geom_text_sf = function(
  sf.focus.labels,
  fontface='bold', color='black', label.size = 0.25,
  size = 3, check_overlap = TRUE
){
  labels = 
    geom_text(
        data=sf.focus.labels, check_overlap=TRUE,
        fontface=fontface, color=color,
        aes(x=lon,y=lat, label=label))
  return(labels)}


mutate_by <- function(.data, group, ...) {

  group_by(.data, !!enquo(group)) %>%
    mutate(...) %>%
    ungroup()

}

plot_limits = function(
  poly.geometry = '',
  # buffer between plot's limits and the geometry 
  # (in unit of geometry column)
  buffer = 0
){
  # creates bounding box
  poly.bbox =
    poly.geometry %>% st_union() %>%
    # buffers the geometry so the ultimate plot has margins
    st_buffer(buffer) %>%
    st_bbox()
  return(
    # returns the 'coord_sf' function which you can add to any plot
    coord_sf(
      xlim = c(poly.bbox['xmin'], poly.bbox['xmax']),
      ylim = c(poly.bbox['ymin'], poly.bbox['ymax']),
      crs = st_crs(poly.geometry)
  ))}

```
