# i. Pre-Clean Data

## 1 CRS
```{r import}

col_crs = st_crs('ESRI:102653')


```

## 2 Parcel Joins

```{r parcel}

# parcel_path =
#   "data/Boulder_Parcels_20211009.geojson"
# boulder.parcel = st_read(parcel_path) %>%
#   rename(ID = OBJECTID, APN=PARCEL_NO) %>%
#   select(ID,APN) %>%
#   st_transform(., col_crs) %>% # North Col State Plane Feet
#   mutate(
#     geometry = st_make_valid(geometry),
#     area = st_area(geometry))
# attributes(boulder.parcel$area) = NULL
# boulder.parcel = boulder.parcel %>% filter(area>0)
#
# address_path =
#   "data/Boulder_AddressPts_20211009.geojson"
# boulder.address = st_read(address_path)%>%
#   st_transform(., col_crs)
# 
# acct_path =
#   "data/Account_Parcels.csv"
# boulder.parcel.acct = read.csv(acct_path)
# 
# build_path =
#   "data/Buildings.csv"
# boulder.parcel.build = read.csv(build_path)
# 
# land_path =
#   "data/Land.csv"
# boulder.parcel.land = read.csv(land_path)
# 
# owner_path =
#   "data/Owner_Address.csv"
# boulder.parcel.owner = read.csv(owner_path)
# 
# permits =
#   "data/Permits.csv"
# B.build = read.csv(build_path)

```

## 3 Parcel Clean

```{r parcel_clean}

# OG_len = nrow(boulder.parcel%>% st_drop_geometry())
# APN_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., APN))
# ID_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., ID, APN))
# area_len = nrow(boulder.parcel[boulder.parcel$area>0,] %>% st_drop_geometry() )
# 
# print(OG_len)
# print(OG_len-APN_len)
# print(OG_len-ID_len)
# print(OG_len-area_len)
# 
# # boulder.parcel[(boulder.parcel$area<=0)&(boulder.parcel$APN %in% dupe_APN),]
# 
# n_occur =
#   data.frame(table(boulder.parcel$APN)) %>%
#   rename(APN=Var1) %>% arrange(-Freq)
# 
# dupe_APN = n_occur[n_occur$Freq > 1,"APN"]
# B.dupe =
#   boulder.parcel[boulder.parcel$APN %in% dupe_APN,] %>% group_by(APN) %>%
#   summarize(geometry = st_union(geometry))
# 
# ggplot() +
#   geom_sf(data=boulder.county, lwd=.1, color='lightgrey') 
# +
#   geom_sf(data=boulder.parcel, lwd=.1) +
#   geom_sf(data=B.dupe,
#           fill='pink', color='red') +
#   plot_limits(poly.geometry= B.dupe)
```


## 4 City & County boundaries 

```{r bound}

# CREATE ERASE FUNCTION
st_erase = function(x, y) {
  st_difference(x, st_union(y))}

state.cities = 
  st_read('data/col_city_boundaries.geojson') %>%
  st_transform(., col_crs) %>%
  rename(
    name = NAME10,
    name_long = NAMELSAD10
  ) %>% 
  mutate(incorporated = 
          ifelse(grepl('city', name_long), 'city',
                 ifelse(grepl('town', name_long), 'town',
                        ifelse(grepl('CDP', name_long), 'CDP',
                               'TRUE'))))
state.counties = 
  st_read('data/col_county_boundaries.geojson') %>%
  st_transform(., col_crs)

state.bound = 
  st_read('data/col_state_boundary.geojson') %>%
  st_transform(., col_crs)

state.cities = 
  state.counties %>% select(LABEL, FULL, geometry) %>%
      rename(name = LABEL, name_long = FULL) %>% 
      mutate(
        name_long = paste('Unincorporated', name_long, sep=" "),
        name = paste(name, 'County', sep=" "),
        incorporated = 'County'
        ) %>%
  st_erase(.,
    state.cities) %>% select(name, name_long, incorporated, geometry) %>%
  rbind(
    .,
    state.cities %>% select(name, name_long, incorporated, geometry)) %>%
  st_sf() %>%
  mutate(first_area = st_area(geometry))

attributes(state.cities$first_area) = NULL

boulder.county = state.counties %>% filter(COUNTY=="BOULDER")
boulder.cities = 
  st_intersection(
    state.cities, 
    boulder.county %>% st_union(.)) %>%
  mutate(land_area = st_area(geometry)) %>%
  filter((incorporated!='County')|grepl('Boulder', name_long))

attributes(boulder.cities$land_area) = NULL

boulder.cities = 
  boulder.cities %>%
  mutate(pct_bould = land_area/first_area) %>%
  filter(pct_bould>=0.1) %>% select(-pct_bould)



boulder.cities.labels = 
  boulder.cities %>%
  st_centroid(., of_largest_polygon = TRUE) %>% 
  filter((incorporated!='County')) %>%
  mutate(
    lon = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[1]]),
    lat = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[2]]),
    size = 
          ifelse(grepl('city', name_long), 2,
                 ifelse(grepl('town', name_long), 1.5,
                        ifelse(grepl('CDP', name_long), 0,
                               0)))) %>% 
  filter(size>0)



boulder.cities[
  st_is(boulder.cities$geometry, 'GEOMETRYCOLLECTION'), 
  'geometry'] = 
  boulder.cities[
    st_is(boulder.cities$geometry, 'GEOMETRYCOLLECTION'), 
    'geometry'] %>%
    st_make_valid(.) %>% 
    st_buffer(1) %>%
    st_union(., by_feature=TRUE) %>%
    st_buffer(-1)


st_write(boulder.cities, "data/boulder_cities.geojson")
st_write(boulder.county, "data/boulder_county.geojson")

###################


```

## 5 Neighborhoods
### A Import
``` {r neighborhoods}

boulder.nhoods = 
  st_read('data/boulder_precincts.geojson') %>%
  st_transform(col_crs) %>% 
  select(ABBREVIATI) %>% rename(nhood_id = ABBREVIATI) %>%
  mutate(
    nhood_id = nhood_id %>% as.character(.),
    neighborhood = nhood_id)

```

### B City Join

``` {r city}

st_true_union = function(a,b) {
   st_agr(a) = "constant"
   st_agr(b) = "constant"
   op1 = st_difference(a, st_union(b))
   op2 = st_difference(b, st_union(a))
   op3 = st_intersection(b, a)
   union = plyr::rbind.fill(op1, op2, op3)
   return(st_as_sf(union))
}


get_majority_intersect = 
  function(focus_sf, focus_id_field, compare_sf, compare_id_field,
           # rename_compare_id_field='',
           minimium_area_pct = .25){
    focus_crs = st_crs(focus_sf)
    
    sf.focus = 
      focus_sf %>%
      select(focus_id_field)
    
    sf.compare = 
      compare_sf %>%
      select(compare_id_field) %>%
      st_transform(focus_crs)
    
    sf.focus_compare = 
      st_true_union(
        sf.focus %>% 
          mutate(focus_area = st_area(geometry)),
        sf.compare %>% 
          select(compare_id_field) %>%
          mutate(compare_area = st_area(geometry))
        )
    
    sf.focus_compare = 
      sf.focus_compare %>% 
      filter(
        !is.na(sf.focus_compare[[compare_id_field]]) & 
          !is.na(sf.focus_compare[[focus_id_field]])) %>%
      group_by_at(vars(c(focus_id_field, compare_id_field))) %>%
      summarize(
        geometry = st_union(geometry),
        focus_area = mean(focus_area),
        compare_area = mean(compare_area)
        ) %>%
      mutate(
        #union_id = seq.int(nrow(.)) %>% as.character(.),
        union_area = st_area(geometry)
      )
    
    attributes(sf.focus_compare$focus_area) = NULL
    attributes(sf.focus_compare$compare_area) = NULL
    attributes(sf.focus_compare$union_area) = NULL
    
    sf.focus_compare$compare_pct = 
      sf.focus_compare$union_area/sf.focus_compare$focus_area
    
    sf.focus_compare = 
      sf.focus_compare %>% 
      filter(compare_pct > minimium_area_pct) %>%
      group_by_at(vars(focus_id_field)) %>% 
      slice(which.max(compare_pct))
    
    
    # if(rename_compare_id_field!=''){
    #   
    #   col_names = colnames(sf.focus_compare)
    #   
    #   old = c(compare_id_field)
    #   all_old = all_of(c(col_names[!col_names %in% old], old))
    #   new = c(rename_compare_id_field)
    #   all_new = all_of(c(col_names[!col_names %in% new], new))
    #   print(sf.focus_compare)
    #   sf.focus_compare = 
    #     sf.focus_compare %>% 
    #     plyr::rename(., c(compare_id_field=rename_compare_id_field))
    #     # select(all_old) %>%
    #     # rename_with(~ all_new, all_old)
    #   
    #   compare_id_field = rename_compare_id_field
    # }
    
    sf.focus = 
      focus_sf %>%
      merge(
        .,
        sf.focus_compare %>%
          select(focus_id_field, compare_id_field) %>% st_drop_geometry(.),
        on=focus_id_field,
        all.x = TRUE
      )
    
    print('number of null joins')
    print(nrow(sf.focus[is.na(sf.focus[[compare_id_field]]),]))
    
    sf.focus[[compare_id_field]][is.na(sf.focus[[compare_id_field]])] = 'NULL'
    
    
    
    return(sf.focus)
  }

boulder.nhoods.c =
  get_majority_intersect(
    boulder.nhoods, 'nhood_id', 
    boulder.cities, 'name',
    # rename_compare_id_field = 'region',
    minimium_area_pct=.1)

boulder.nhoods.c =
  boulder.nhoods.c %>%
  merge(
    .,
    boulder.nhoods.c %>%
      group_by(name) %>%
      summarise(name_count = n()) %>%
      st_drop_geometry(.),
    on='name'
        ) %>%
  rename(
    city = name,
    city_count = name_count
  )
  
###########

```

### C Zillow Join 

``` {r Zillow}
library(rgdal)

# The input file geodatabase
fgdb = "data/Zillow_Neighborhoods/ZillowNeighborhoods.gdb"

# List all feature classes in a file geodatabase
subset(ogrDrivers(), grepl("GDB", name))
fc_list = ogrListLayers(fgdb)
print(fc_list)

# Read the feature class
boulder.nhoods.z =
  readOGR(dsn=fgdb,layer="ZillowNeighborhoodsAreas") %>%
  st_as_sf(.)

boulder.nhoods.z =  
  boulder.nhoods.z %>%
  filter(
    boulder.nhoods.z$State=='CO') %>%
  st_transform(col_crs) %>%
  rename(
    zhood = Name,
    zhood_id = RegionID
  ) %>%
  select(zhood, zhood_id)

boulder.nhoods.cz =
  get_majority_intersect(
    boulder.nhoods.c, 'nhood_id', 
    boulder.nhoods.z, 'zhood_id',
    # rename_compare_id_field = 'region',
    minimium_area_pct=.1)

boulder.nhoods.cz =
  boulder.nhoods.cz %>%
  merge(
    .,
    boulder.nhoods.z %>%
      select(zhood_id, zhood) %>%
      st_drop_geometry(.),
    on=zhood_id,
    all.x = TRUE) %>%
  mutate_by(., group=zhood_id, zhood_count = n())

boulder.nhoods.cz[boulder.nhoods.cz$zhood_id=='NULL', 'zhood_count']=0

boulder.nhoods.cz %>% 
  group_by(zhood_id) %>% 
  summarize(count = mean(zhood_count),
            first = first(zhood)) %>% 
  st_drop_geometry() %>%
  arrange(count)


boulder.nhoods.cz =
  boulder.nhoods.cz %>%
  mutate(
    name = ifelse(
      zhood_id=='NULL', 
      city,
      zhood
    )) %>%
  mutate_by(
    group=name, 
    name_count = n(),
    neighborhood = ifelse(
      name_count > 1,
      paste(name, row_number()),
      name)
    )
      
boulder.nhoods.cz %>% arrange(-name_count)

```

### D Orientation Join

``` {r orient}

boulder.nhoods.focus.group =
  boulder.nhoods.cz %>%
    filter(boulder.nhoods.cz$name_count>1) %>%
  mutate_by(
    group=name,
    group.geometry = st_union(geometry),
    group.centroid = st_centroid(group.geometry),
    group.area = st_area(group.geometry),
    nhood.geometry = geometry
    ) %>%
  mutate(nhood.area = st_area(geometry))

attributes(boulder.nhoods.focus.group$group.area) = NULL
attributes(boulder.nhoods.focus.group$nhood.area) = NULL


## function to create orientation sector sf (NESW) (NE,SE,SW,NW) (Center)
get_max_yx_lengths = function(sf_focus){
  f_coords = 
    sf_focus %>% 
      st_union(.) %>%
      st_centroid(.) %>%
      st_coordinates(.)

  x = f_coords[1]
  y = f_coords[2]
  
  f_box = sf_focus %>% st_bbox(.)
  
  y_length = max(f_box$ymax-y, y-f_box$ymin)
  x_length = max(f_box$xmax-x, x-f_box$xmin)
  
  xy_list = list()
  
  xy_list['ymax'] = y_length
  xy_list['xmax'] = x_length
  return(xy_list)
}

st_envelope = function(sf_focus){
  xy_list = get_max_yx_lengths(sf_focus)

  box = sf_focus %>% 
        c(diff(st_bbox(.)[c(1, 3)]), diff(st_bbox(.)[c(2, 4)]))
  buff_size = max(box$ymax, box$xmax)
  
  bbox_wrap = function(x) st_as_sfc(st_bbox(x))
  
  sf.focus
    sf_focus %>%
    st_union(.) %>%
    st_centroid(.) %>%
    st_buffer(., buff_size) %>%
    st_sf(.) %>%
    mutate(bbox = map(geometry, bbox_wrap),
           geometry = st_as_sfc(do.call(rbind, bbox))) %>%
    select(-bbox) 
    
  return(sf.focus)
}
  
sf_rotated_fish = function(sf_focus, rotate_angle=45){
  #focus_crs = st_crs(3857)
  focus_crs = st_crs(sf_focus)
  
  sf.focus = sf_focus %>% 
    st_transform(., focus_crs) %>% 
    st_union(.) %>%
    st_geometry(.)
  
  
  xy_list = get_max_yx_lengths(sf.focus)

  box = sf_focus %>% 
        st_transform(., focus_crs)  %>%
        c(diff(st_bbox(.)[c(1, 3)]), diff(st_bbox(.)[c(2, 4)]))
  buff_size = max(box$ymax, box$xmax)
  bbox_wrap = function(x) st_as_sfc(st_bbox(x))
  
  rot = function(a) matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2)
  tran = function(geo, ang, center) (geo - center) * rot(ang * pi / 180) + center
  
  sf.input =
    sf.focus %>%
    st_sf(.) %>%
    st_union(.) %>%
    st_centroid(.) %>%
    st_buffer(., buff_size) %>%
    st_sf(.) %>%
    mutate(bbox = map(geometry, bbox_wrap),
           geometry = st_as_sfc(do.call(rbind, bbox))) %>%
    select(-bbox) %>%
    st_geometry(.)
  
  center = st_centroid(st_union(sf.input))
  sf.grid = st_make_grid(
    tran(sf.input, -rotate_angle, center), 
    square = TRUE,
    n = c(2,2),
    what='polygons'
    )
  sf.grid_rotate = 
    tran(sf.grid, rotate_angle, center) %>%
    st_sf(., crs=focus_crs) %>%
    st_transform(., st_crs(sf_focus))

return(sf.grid_rotate)
}

  

  
get_fish_name = function(
    focus_name,
    return_all=FALSE
                         ){
  
  boulder.nhoods.focus = boulder.nhoods.focus.group %>%
    filter(name == focus_name)
  
  bbox_wrap = function(x) st_as_sfc(st_bbox(x))
  xy_list = get_max_yx_lengths(boulder.nhoods.focus)
  
  boulder.nhoods.focus.fish = 
    rbind(
      sf_rotated_fish(
         boulder.nhoods.focus,
         rotate_angle=45) %>% 
        mutate(orientation = c('W','S','N','E')) %>%
        st_intersection(., boulder.nhoods.focus),
      
      st_make_grid(
        boulder.nhoods.focus %>% 
          st_union(.) %>%
          st_centroid(.) %>%
          st_buffer(., max(xy_list$ymax, xy_list$xmax)),
        square = TRUE,
        n = c(2,2),
        what='polygons') %>% 
      st_sf(.) %>%
      mutate(orientation = c('SW','SE','NW','NE')) %>%
      st_intersection(., boulder.nhoods.focus),
      
      boulder.nhoods.focus %>% 
        st_union(.) %>%
        st_centroid(.) %>%
        st_buffer(., max(xy_list$ymax, xy_list$xmax)*.35) %>% 
      st_sf(.) %>%
      mutate(orientation = c('Center')) %>%
      st_intersection(., boulder.nhoods.focus)
      ) %>%
    mutate(
      nhood.pct = nhood.area/group.area,
      orient.area = st_area(geometry)
    )
  attributes(boulder.nhoods.focus.fish$orient.area) = NULL
  
  boulder.nhoods.focus.fish.group = 
    boulder.nhoods.focus.fish %>%
    mutate(orient.pct = orient.area/nhood.area) %>%
    group_by(nhood_id) %>%
    slice(which.max(orient.pct)) %>%
    mutate(
      geometry = nhood.geometry,
      orient.name = ifelse(
        nhood.pct >= .6,
        name,
        paste(orientation, name))
      ) %>%
    st_drop_geometry(.) %>%
    select(nhood_id, orient.name, orientation)
  
  if(return_all==FALSE){
    return(
      boulder.nhoods.focus.fish.group 
      )
  } else{
    return(
      boulder.nhoods.focus.fish %>%
        mutate(orient.pct = orient.area/nhood.area)
      )
  }
  
}

boulder.nhoods.orient = 
  do.call(rbind.data.frame, 
        lapply(unique(boulder.nhoods.focus.group$name), get_fish_name)) %>%
  mutate_by(
      group=orient.name, 
      orient.count = n(),
      orient.name = ifelse(
        orient.count > 1,
        paste(orient.name, row_number()),
        orient.name)
      )
      
glimpse(boulder.nhoods.orient)


random_sample = 
  boulder.nhoods.focus.group$name[sample.int(length(boulder.nhoods.focus.group$name), 1)]

boulder.nhoods.focus.fish_all =
  get_fish_name(random_sample, return_all=TRUE)

boulder.nhoods.focus.fish = 
  boulder.nhoods.focus.fish_all %>%
    mutate(orient.pct = orient.area/nhood.area) %>%
    group_by(nhood_id) %>%
    slice(which.max(orient.pct)) %>%
    mutate(
      geometry = nhood.geometry,
      orient.name = ifelse(
        nhood.pct >= .6,
        name,
        paste(orientation, name))
      )

ggplot() + 
  geom_sf(
    data = 
      boulder.nhoods.focus.fish_all %>%
        group_by(orientation) %>%
        summarize(geometry=st_union(geometry)), 
    fill='transparent',
    color='grey50') + 
  geom_sf(
    data = 
      boulder.nhoods.focus.fish_all%>%
        mutate(orient.pct = orient.area/nhood.area) %>%
        group_by(nhood_id) %>%
        slice(which.max(orient.pct)),
    aes(fill=nhood_id), alpha=.5,
    color='black', linetype = "dashed") +
  geom_sf(
    data = 
      boulder.nhoods.focus.fish_all %>% 
        st_union(.) %>% st_centroid(.), 
    color='black') +
  # geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
  #         lwd=.1, linetype = "dashed") + 
  # geom_sf(data = boulder.county, fill = 'transparent', color='black',
  #         lwd=1) + 
  geom_text_sf(sf_to_labels(
    boulder.nhoods.focus.fish_all %>% 
      group_by(orientation) %>%
      summarize(geometry = st_union(geometry)), 
    'orientation'), 
    color='grey50', 
    size=1) +
  geom_text_sf(sf_to_labels(
    boulder.nhoods.focus.fish, 
    'orient.name'), color='black') +
  theme(legend.position = "none") + 
  mapTheme() +
  plot_limits(poly.geometry = boulder.nhoods.focus.fish$geometry)



#########

boulder.nhoods.czf = 
  boulder.nhoods.cz %>%
  merge(
    .,
    boulder.nhoods.orient %>% select(nhood_id, orient.name, orient.count),
    on = 'nhood_id',
    all.x = TRUE
  )
boulder.nhoods.czf$orient.count[is.na(boulder.nhoods.czf$orient.count)] = 0

boulder.nhoods.czf = 
  boulder.nhoods.czf %>% 
  select(-name_count) %>%
  mutate(
    name = ifelse(
      orient.count > 0,
      orient.name,
      ifelse(
        zhood_count == 1,
        zhood,
        city
      ))
  ) %>% 
  mutate_by(
    group=name,
    name_count = n(),
    neighborhood = ifelse(
      name_count > 1,
      paste(name, row_number()),
      name)
    ) %>%
  rename(sub_nhood = zhood) %>%
  select(
    nhood_id,
    city,
    neighborhood
  )

boulder.nhoods.czf
st_write(
  boulder.nhoods.czf, 
  "data/boulder_neighborhoods.geojson")

```

### E Combine NHood

``` {r add_nhood}

boulder.nhoods = boulder.nhoods.czf

boulder.sales =
  boulder.sales %>% 
  #select_if(!names(.) %in% c('neighborhood')) %>%
  st_join(., boulder.nhoods)

boulder.sales %>%
  group_by(neighborhood) %>%
  summarize(
    house_count = n()
    )

boulder.nhoods =
  boulder.nhoods %>%
  merge(
    .,
    aggregate(boulder.sales$MUSA_ID,
            by=list(boulder.sales$neighborhood), FUN=length) %>%
      rename(neighborhood = Group.1, house_count=x),
    by = 'neighborhood', all.x=TRUE) 

boulder.nhoods$house_count[is.na(boulder.nhoods$house_count)] = 0

second_max = function(vector){
  vector_mx = max(vector)
  vector_cut = 
  vector[
    vector<vector_mx]
  return(max(vector_cut))
}

hist(boulder.nhoods$house_count, breaks=50)

ggplot() + 
  # geom_sf(
  #   data = boulder.cities, 
  #   aes(fill=incorporated), 
  #   color='transparent') + 
  geom_sf(
    data = boulder.nhoods, 
    aes(fill=nhood_id), 
    color='grey50') + 
  geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
          lwd=.1, linetype = "dashed") + 
  geom_sf(data = boulder.county, fill = 'transparent', color='black',
          lwd= 1) + 
  geom_text(
    data=boulder.cities.labels, check_overlap=TRUE,
    size = ifelse(boulder.cities.labels$size==2,2.5,2), 
    fontface='bold', color='black',
    aes(x=lon,y=lat, label=name)) + 
   theme(legend.position = "none") + 
  mapTheme()

```
## 6 Schools
### A Proto

```{r html}

library(rvest)

school.raw = 
  do.call(rbind, table) %>% as.data.frame(.) %>%
  mutate(
    id = id %>% gsub("zcsch", "sch", .),
    url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/{id}.geojson'),
    name = name %>% 
      gsub("Display ", "", .) %>% 
      gsub("Attendance Zone Boundary", "", .),
    geometry = sapply(url, function(url){
       geom = st_read(url)
       return(geom[[2]] %>% as.vector())
      })
    ) %>%
  st_sf(., crs=st_crs('EPSG: 4326')) %>% 
  st_transform(col_crs)

st_write(school.raw, "data/boulder_school_boundary.geojson")

st_make_valid
school.raw


# school_geoms = 
#   c('https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_1570_2790.geojson',
#     'https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_0480_9544.geojson') %>%
#       sapply(., function(url){
#        geom = st_read(url)
#        return(geom[[2]] %>% as.vector())
#       })
# school_geoms 

as.vector(school_geoms) %>% st_sfc()

glimpse(col.districts.links)

```


### B get district links

```{r table}
library(rvest)

col.districts.links = 
  read_csv('data/col_district_links.csv') %>%
  mutate(
    district_type_id = 
      paste(
        district_id, 
        school_level %>% substr(., 1, 1),
        sep='_'
  ))

```

### C get school links

``` {r school}

get_table_attrs = function(dist.row){
  
  dist.row =
    map(dist.row, unlist)
  
  dist.url = dist.row$url
  
  dist.page = 
    read_html(dist.url)
  
  dist.table = 
    dist.page %>%
    html_nodes("[class='table table-striped table-bordered table-hover table-condensed']")
  
  ###
  
  dist.table.input =
    dist.table %>% 
    html_elements("input")
  
  dist.table.ids = 
    dist.table.input %>%
    html_attr('id') %>% 
    gsub('zcsch_','sch_', .) %>%
    data.frame(map_id = .)
    
  ###
  
  dist.table.text = 
    dist.table %>%
    html_nodes('tr')  %>%
    html_text2(.) %>% 
    as.vector(.)
  
  dist.table.name = 
    dist.table.text[1] %>% 
    gsub('List of ','', .)
  
  dist.table.columns = 
    dist.table.text[2] %>%
    strsplit(., "\t") %>%
    unlist(., recursive = TRUE, use.names = FALSE)
  
  table_to_farm = function(row_str){
    row_str = 
      row_str %>%
      gsub("[\n]",'',.)
    
    row_row = 
      row_str %>% 
      strsplit(., "[\t]") %>%
      unlist(., recursive = TRUE, use.names = FALSE)
    
    return(row_row[row_row!=""])
  }
  
  dist.table.list = 
    dist.table.text[3:length(dist.table.text)] %>%
    sapply(., FUN=table_to_farm)
  
  dist.table.list = 
    dist.table.list[lapply(dist.table.list, length) > 0]
  
  if (
     mean(sapply(dist.table.list, length)) != (length(dist.table.columns)-1)
   ){
     print('table_list_length')
     print(mean(sapply(dist.table.list, length)))
     print(dist.table.columns)
     
     
     bad = 
      dist.table.list[lapply(dist.table.list, length)<4] %>% names(.)
     print(dist.table.list[lapply(dist.table.list, length)<4])
     print(bad)
     
     for (idx in seq(length(bad))){
       bad_row = dist.table.list[lapply(dist.table.list, length)<4][[idx]]
       print(bad_row)
       sch_nm = bad_row[1]
       dist = bad_row[2]
       stu = bad_row[3]
       fix = c(sch_nm, dist, 'null', stu)
       
       print(fix)
       
       dist.table.list[lapply(dist.table.list, length)<4][[idx]] = fix
     }
   }
  
  dist.df = 
    dist.table.list %>%
    do.call(rbind.data.frame, .)
  
  if (
     mean(nrow(dist.df)) != (nrow(dist.table.ids))
   ){
     print('text table length')
     print(nrow(dist.df))
     print('id length')
     print(nrow(dist.table.ids))
  }
  
  dist.df = 
    cbind(dist.table.ids,dist.df)
  
  dist.table.columns = c(
    'map_id',
    'school_name_full',
    'dist_name_full',
    'school_city',
    'school_students'
  )
  colnames(dist.df) = dist.table.columns
  
  dist.df = 
    dist.df %>%
    mutate(
      dist_name = dist.row$name %>% tools::toTitleCase(.),
      school_level = dist.row$school_level %>% tools::toTitleCase(.),
      dist_id_full = dist.row$district_type_id,
      dist_id = dist.row$district_id,
      school_name = school_name_full %>% 
        gsub(glue('{school_level} School'), '', .) %>% trimws(.)
    )
  
  dist.columns = colnames(dist.df)
  dist.columns = c("map_id" ,dist.columns[2:length(dist.columns)] %>% sort(.))
  dist.df = dist.df[,dist.columns]
  
  return(dist.df)
}

col.districts.table = 
  col.districts.links %>%
  apply(., 1, get_table_attrs) %>%
  do.call(rbind.data.frame, .) %>%
  mutate(
    map_url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/{map_id}.geojson'))
```

### D get geometries

``` {r geom}

geom_funct = function(url, map_id){
      geom =
      tryCatch(
        {
            st_read(url)$geometry
        },
        error = function(e){
            ''
        })
      # print(geom)
      # if(length(geom)>1){print(map_id)}
      return(geom)
      }

#geom_funct(col.districts.table$map_url, col.districts.table$map_id)
# col.districts.geoms = 
#   col.districts.table %>%
#   mutate(
#     geometry = 
#       tryCatch(
#         st_make_valid(st_read(map_url, quiet=TRUE)$geometry), 
#         error = function(e) { c(e) })
#   ) %>%
#   st_sf(., crs=st_crs('EPSG: 4326')) %>%
#   st_transform(col_crs)
# col.districts.geoms$geometry

geom_list = list()
bad_list = list()
for (url in col.districts.table$map_url){

  geom_list[[url]] =
    tryCatch(st_make_valid(st_read(url, quiet=TRUE)$geometry) %>% st_union(.), 
             error = function(e) { cat('In error handler\n'); print(e); e })
  
}

check = 
  geom_list %>% map_df(as_tibble)

check$map_url = names(geom_list) %>% as.vector()

col.districts.geom = 
  col.districts.table %>% 
  merge(., check, on='map_url') %>%
  st_sf(., crs=st_crs('EPSG: 4326')) %>%
  st_transform(col_crs)

st_write(col.districts.geom, "col_school_boundary.geojson")


col.dist.polys = 
  col.districts.geom %>%
  st_transform(col_crs) %>% mutate(pre_area = st_area(geometry)) %>%
  st_intersection(., boulder.county %>% st_union()) %>%
  mutate(post_area = st_area(geometry))

attributes(col.dist.polys$pre_area) = NULL
attributes(col.dist.polys$post_area) = NULL

col.dist.polys = 
  col.dist.polys %>% 
  mutate(pct_area = post_area/ pre_area) %>%
  filter(pct_area>0.01)

```



## 6 Schools


```{r schools}

# glimpse(col.districts.table)
# 
# 
# 
#   as_tibble(.,.name_repair ='minimal')
# 
# col.districts.table =
#   #col.districts.links$url %>%
#   c(col.districts.links$url[1]) %>%
#   sapply(., get_table_attrs)
# 
# 
# 
# 
# # # %>%
# #     #do.call(rbind, .) %>%
# #     as.data.frame(.)
# 
# glimpse(col.districts.table)


school.dist.scores = 
  read_csv('data/colorado_district_rankings_2021.csv') %>%
  mutate(
    GEOID = district_id %>% 
      sapply(., FUN = function(id){
        paste('08', gsub("\"", "", id), sep='')}), 
    district_id = district_id %>% 
      sapply(., FUN = function(id){gsub("\"", "", id)})) 




boulder.dist.ele = 
  col.dist.polys %>% 
  filter(school_level == 'Elementary')

school.elementary.rank =
  read_csv('data/colorado_elementary_rankings_2020.csv') %>%
  rename(full_school_id = school_id) %>%
  mutate(
    full_school_id = full_school_id %>% 
      sapply(., FUN = function(id){gsub("\"", "", id)}),
    district_id = full_school_id %>% 
      sapply(., FUN = function(id){substr(id, 1, 4)}),
    school_id = full_school_id %>% 
      sapply(., FUN = function(id){substr(id, 7, 10)})
    ) %>% as.data.frame(.)

dist_ids = substr(school.dist.polys$GEOID, 3, 6)

school.elementary.dist = 
  school.elementary.rank[school.elementary.rank$district_id %in% dist_ids,] %>%
  mutate(
    boundary_url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_{district_id}_{school_id}.geojson'))


school.elementary.pts = 
  st_read('data/col_elementary_points.geojson') %>%
  st_transform(col_crs) 




ggplot() + 
  # geom_sf(
  #   data = boulder.cities, 
  #   aes(fill=incorporated), 
  #   color='transparent') + 
  geom_sf(
    data = boulder.nhoods.z, 
    aes(fill=Name), 
    color='transparent') + 
  geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
          lwd=.1, linetype = "dashed") +
  geom_sf(data = boulder.county,
          fill = 'transparent', color='black',
          lwd=1) +
  geom_text(
    data=boulder.cities.labels, check_overlap=TRUE,
    size = ifelse(boulder.cities.labels$size==2,2.5,2),
    fontface='bold', color='black',
    aes(x=lon,y=lat, label=name)) +
  theme(legend.position = "none")+ 
  mapTheme()

```

## 9 Assorted Variable Creation

```{r assorted}

boulder.sales$nbrBaths =  
  boulder.sales$nbrFullBaths + boulder.sales$nbrHalfBaths

# 3. Full Bathroom
boulder.variables = add_v(
  "nbrBaths",     3,    "Internal"
)

# i. Num of Bedrooms
boulder.variables = add_v(
  "nbrBedRoom",    1,    "Internal"
)

# 2. Main Square Foot
boulder.variables = add_v(
  "mainfloorSF",   2,    "Internal"
)


# N. Nearest Neighbor
boulder.variables = add_v(
  "lagPrice",      99,   "Spatial"
)

# 3. Built Year
boulder.variables = add_v(
  "EffectiveYear",   3,    "Internal"
)

```

## 10 Set Up boulder.data & 0/1 Partition

variables are one of these types:
1.	Internal characteristics (e.g. bedrooms)
2.	amenities/public services (e.g. proximity to parks)
3.	spatial structure (e.g. nearby prices)

Split up the data between sales prices known, and the sales prices that are set to 0 to be predicted 

```{r price_dataset}

ID_fields = c(
#   ID given by michael
  "MUSA_ID",
#   whether they should be predicted (1) or already have a price (0)
  "toPredict"
  )


boulder.data = boulder.sales[,c(
  ID_fields,
  boulder.variables$var_name,
  'geometry'
  )]

boulder.dv = boulder.variables[!boulder.variables$var_num %in% c(0,99), 'var_name']

boulder.predict.0 = boulder.data %>%
  filter(.,toPredict == 0)
boulder.predict.1 = boulder.data %>%
  filter(., toPredict == 1)

boulder.variables


glimpse(boulder.data)

```

