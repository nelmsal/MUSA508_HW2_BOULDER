# i. Data
## i.A Gathering Data
*Briefly describe your methods for gathering the data.*

### i.A.1 Import Data
```{r import}

col_crs = st_crs('ESRI:102653')


```

### i.A.2 Parcel Joins


```{r parcel}

parcel_path =
  "data/Boulder_Parcels_20211009.geojson"
boulder.parcel = st_read(parcel_path) %>%
  rename(ID = OBJECTID, APN=PARCEL_NO) %>%
  select(ID,APN) %>%
  st_transform(., col_crs) %>% # North Col State Plane Feet
  mutate(
    geometry = st_make_valid(geometry),
    area = st_area(geometry))
attributes(boulder.parcel$area) = NULL
boulder.parcel = boulder.parcel %>% filter(area>0)

# address_path =
#   "data/Boulder_AddressPts_20211009.geojson"
# boulder.address = st_read(address_path)%>%
#   st_transform(., col_crs)
# 
# acct_path =
#   "data/Account_Parcels.csv"
# boulder.parcel.acct = read.csv(acct_path)
# 
# build_path =
#   "data/Buildings.csv"
# boulder.parcel.build = read.csv(build_path)
# 
# land_path =
#   "data/Land.csv"
# boulder.parcel.land = read.csv(land_path)
# 
# owner_path =
#   "data/Owner_Address.csv"
# boulder.parcel.owner = read.csv(owner_path)
# 
# permits =
#   "data/Permits.csv"
# B.build = read.csv(build_path)

```

### i.A.3 Parcel Clean

```{r parcel_clean}

# OG_len = nrow(boulder.parcel%>% st_drop_geometry())
# APN_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., APN))
# ID_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., ID, APN))
# area_len = nrow(boulder.parcel[boulder.parcel$area>0,] %>% st_drop_geometry() )
# 
# print(OG_len)
# print(OG_len-APN_len)
# print(OG_len-ID_len)
# print(OG_len-area_len)
# 
# # boulder.parcel[(boulder.parcel$area<=0)&(boulder.parcel$APN %in% dupe_APN),]
# 
# n_occur =
#   data.frame(table(boulder.parcel$APN)) %>%
#   rename(APN=Var1) %>% arrange(-Freq)
# 
# dupe_APN = n_occur[n_occur$Freq > 1,"APN"]
# B.dupe =
#   boulder.parcel[boulder.parcel$APN %in% dupe_APN,] %>% group_by(APN) %>%
#   summarize(geometry = st_union(geometry))
# 
# ggplot() +
#   geom_sf(data=boulder.county, lwd=.1, color='lightgrey') 
# +
#   geom_sf(data=boulder.parcel, lwd=.1) +
#   geom_sf(data=B.dupe,
#           fill='pink', color='red') +
#   plot_limits(poly.geometry= B.dupe)
```


### i.5 boundaries 

```{r bound}

# CREATE ERASE FUNCTION
st_erase = function(x, y) {
  st_difference(x, st_union(y))}

state.cities = 
  st_read('data/col_city_boundaries.geojson') %>%
  st_transform(., col_crs) %>%
  rename(
    name = NAME10,
    name_long = NAMELSAD10
  ) %>% 
  mutate(incorporated = 
          ifelse(grepl('city', name_long), 'city',
                 ifelse(grepl('town', name_long), 'town',
                        ifelse(grepl('CDP', name_long), 'CDP',
                               'TRUE'))))
state.counties = 
  st_read('data/col_county_boundaries.geojson') %>%
  st_transform(., col_crs)

state.bound = 
  st_read('data/col_state_boundary.geojson') %>%
  st_transform(., col_crs)

state.cities = 
  state.counties %>% select(LABEL, FULL, geometry) %>%
      rename(name = LABEL, name_long = FULL) %>% 
      mutate(
        name_long = paste('Unincorporated', name_long, sep=" "),
        name = paste(name, 'County', sep=" "),
        incorporated = 'County'
        ) %>%
  st_erase(.,
    state.cities) %>% select(name, name_long, incorporated, geometry) %>%
  rbind(
    .,
    state.cities %>% select(name, name_long, incorporated, geometry)) %>%
  st_sf() %>%
  mutate(first_area = st_area(geometry))

attributes(state.cities$first_area) = NULL

boulder.county = state.counties %>% filter(COUNTY=="BOULDER")
boulder.cities = 
  st_intersection(
    state.cities, 
    boulder.county %>% st_union(.)) %>%
  mutate(land_area = st_area(geometry)) %>%
  filter((incorporated!='County')|grepl('Boulder', name_long))

attributes(boulder.cities$land_area) = NULL

boulder.cities = 
  boulder.cities %>%
  mutate(pct_bould = land_area/first_area) %>%
  filter(pct_bould>=0.1) %>% select(-pct_bould)

boulder.cities.labels = 
  boulder.cities %>%
  st_centroid(., of_largest_polygon = TRUE) %>% 
  filter((incorporated!='County')) %>%
  mutate(
    lon = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[1]]),
    lat = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[2]]),
    size = 
          ifelse(grepl('city', name_long), 2,
                 ifelse(grepl('town', name_long), 1.5,
                        ifelse(grepl('CDP', name_long), 0,
                               0)))) %>% 
  filter(size>0)

boulder.nhoods = 
  st_read('data/boulder_precincts.geojson') %>%
  st_transform(col_crs) %>% 
  select(ABBREVIATI) %>% rename(nhood_id = ABBREVIATI) %>%
  mutate(
    nhood_id = nhood_id %>% as.character(.),
    neighborhood = nhood_id)



boulder.cities[
  st_is(boulder.cities$geometry, 'GEOMETRYCOLLECTION'), 
  'geometry'] = 
  boulder.cities[
    st_is(boulder.cities$geometry, 'GEOMETRYCOLLECTION'), 
    'geometry'] %>%
    st_make_valid(.) %>% 
    st_buffer(1) %>%
    st_union(., by_feature=TRUE) %>%
    st_buffer(-1)


st_true_union = function(a,b) {
   st_agr(a) = "constant"
   st_agr(b) = "constant"
   op1 = st_difference(a, st_union(b))
   op2 = st_difference(b, st_union(a))
   op3 = st_intersection(b, a)
   union = plyr::rbind.fill(op1, op2, op3)
   return(st_as_sf(union))
}

boulder.cities_nhoods = 
  st_true_union(
    boulder.nhoods %>% 
      select(nhood_id) %>%
      mutate(nhood_area = st_area(geometry)),
    boulder.cities %>% 
      select(name) %>%
      mutate(city_area = st_area(geometry))
    ) %>%  
  filter(!is.na(name) & !is.na(nhood_id)) %>%
  group_by(nhood_id, name) %>%
  summarize(
    geometry = st_union(geometry),
    nhood_area = mean(nhood_area),
    city_area = mean(city_area)
    ) %>%
  mutate(
    #union_id = seq.int(nrow(.)) %>% as.character(.),
    union_area = st_area(geometry)
  )

attributes(boulder.cities_nhoods$nhood_area) = NULL
attributes(boulder.cities_nhoods$city_area) = NULL
attributes(boulder.cities_nhoods$union_area) = NULL

boulder.cities_nhoods$city_pct = 
  boulder.cities_nhoods$union_area/boulder.cities_nhoods$nhood_area

boulder.cities_nhoods = 
  boulder.cities_nhoods %>% 
  filter(city_pct > .5) %>%
  rbind(
    .,
    boulder.cities_nhoods[
      !(boulder.cities_nhoods$nhood_id %in%   boulder.cities_nhoods.5$nhood_id) &
      boulder.cities_nhoods$name != 'Boulder County',]
        ) %>%
  rename(region = name)

boulder.nhoods = 
  boulder.nhoods %>%
  merge(
    .,
    boulder.cities_nhoods %>%
      select(nhood_id, region) %>% st_drop_geometry(.),
    on='nhood_id'
  )

boulder.nhoods %>%
  group_by(region) %>%
  summarise(count = n()) %>%
  st_drop_geometry(.) %>%
  arrange(count)

library(rgdal)

# The input file geodatabase
fgdb <- "data/Zillow_Neighborhoods/ZillowNeighborhoods.gdb"

# List all feature classes in a file geodatabase
subset(ogrDrivers(), grepl("GDB", name))
fc_list <- ogrListLayers(fgdb)
print(fc_list)

# Read the feature class
boulder.nhoods.z =
  readOGR(dsn=fgdb,layer="ZillowNeighborhoodsAreas") %>%
  st_as_sf(.)

boulder.nhoods.z =  
  boulder.nhoods.z %>%
  filter(
    boulder.nhoods.z$State=='CO') %>%
  st_transform(col_crs)



##########################################

boulder.sales =
  boulder.sales %>% 
  select_if(!names(.) %in% c('neighborhood')) %>%
  st_join(., boulder.nhoods)

# boulder.sales %>%
#   group_by(neighborhood) %>%
#   summarize(
#     house_count = tally(MUSA_ID),
#     predict.0_count = tally(toPredict == '0'),
#     predict.1_count = tally(toPredict == '1')
#   )



boulder.nhoods =
  boulder.nhoods %>%
  merge(
    .,
    aggregate(boulder.sales$MUSA_ID,
            by=list(boulder.sales$neighborhood), FUN=length) %>%
      rename(neighborhood = Group.1, house_count=x),
    by = 'neighborhood', all.x=TRUE) 

boulder.nhoods$house_count[is.na(boulder.nhoods$house_count)] = 0

second_max = function(vector){
  vector_mx = max(vector)
  vector_cut = 
  vector[
    vector<vector_mx]
  return(max(vector_cut))
}

hist(boulder.nhoods$house_count, breaks=50)

ggplot() + 
  # geom_sf(
  #   data = boulder.cities, 
  #   aes(fill=incorporated), 
  #   color='transparent') + 
  geom_sf(
    data = boulder.nhoods.z, 
    aes(fill=Name), 
    color='transparent') + 
  geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
          lwd=.1, linetype = "dashed") + 
  geom_sf(data = boulder.county, fill = 'transparent', color='black',
          lwd=1) + 
  geom_text(
    data=boulder.cities.labels, check_overlap=TRUE,
    size = ifelse(boulder.cities.labels$size==2,2.5,2), 
    fontface='bold', color='black',
    aes(x=lon,y=lat, label=name)) + 
   theme(legend.position = "none")+ 
  mapTheme()

unique(boulder.nhoods.z$City)

```


```{r html}

library(rvest)








school.raw = 
  do.call(rbind, table) %>% as.data.frame(.) %>%
  mutate(
    id = id %>% gsub("zcsch", "sch", .),
    url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/{id}.geojson'),
    name = name %>% 
      gsub("Display ", "", .) %>% 
      gsub("Attendance Zone Boundary", "", .),
    geometry = sapply(url, function(url){
       geom = st_read(url)
       return(geom[[2]] %>% as.vector())
      })
    ) %>%
  st_sf(., crs=st_crs('EPSG: 4326')) %>% 
  st_transform(col_crs)

st_write(school.raw, "data/boulder_school_boundary.geojson")

st_make_valid
school.raw


# school_geoms = 
#   c('https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_1570_2790.geojson',
#     'https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_0480_9544.geojson') %>%
#       sapply(., function(url){
#        geom = st_read(url)
#        return(geom[[2]] %>% as.vector())
#       })
# school_geoms 

as.vector(school_geoms) %>% st_sfc()

col.districts.links = 
  read_csv('data/col_district_links.csv') %>%
  mutate(
    district_type_id = 
      paste(
        district_id, 
        school_level %>% substr(., 1, 1),
        sep='_'
  ))
glimpse(col.districts.links)

```

```{r table}

get_table_attrs = function(dist.row){
  
  dist.row =
    map(dist.row, unlist)
  
  dist.url = dist.row$url
  
  dist.page = 
    read_html(dist.url)
  
  dist.table = 
    dist.page %>%
    html_nodes("[class='table table-striped table-bordered table-hover table-condensed']")
  
  ###
  
  dist.table.input =
    dist.table %>% 
    html_elements("input")
  
  dist.table.ids = 
    dist.table.input %>%
    html_attr('id') %>% 
    gsub('zcsch_','sch_', .) %>%
    data.frame(map_id = .)
    
  ###
  
  dist.table.text = 
    dist.table %>%
    html_nodes('tr')  %>%
    html_text2(.) %>% 
    as.vector(.)
  
  dist.table.name = 
    dist.table.text[1] %>% 
    gsub('List of ','', .)
  
  dist.table.columns = 
    dist.table.text[2] %>%
    strsplit(., "\t") %>%
    unlist(., recursive = TRUE, use.names = FALSE)
  
  table_to_farm = function(row_str){
    row_str = 
      row_str %>%
      gsub("[\n]",'',.)
    
    row_row = 
      row_str %>% 
      strsplit(., "[\t]") %>%
      unlist(., recursive = TRUE, use.names = FALSE)
    
    return(row_row[row_row!=""])
  }
  
  dist.table.list = 
    dist.table.text[3:length(dist.table.text)] %>%
    sapply(., FUN=table_to_farm)
  
  dist.table.list = 
    dist.table.list[lapply(dist.table.list, length) > 0]
  
  if (
     mean(sapply(dist.table.list, length)) != (length(dist.table.columns)-1)
   ){
     print('table_list_length')
     print(mean(sapply(dist.table.list, length)))
     print(dist.table.columns)
     
     
     bad = 
      dist.table.list[lapply(dist.table.list, length)<4] %>% names(.)
     print(dist.table.list[lapply(dist.table.list, length)<4])
     print(bad)
     
     for (idx in seq(length(bad))){
       bad_row = dist.table.list[lapply(dist.table.list, length)<4][[idx]]
       print(bad_row)
       sch_nm = bad_row[1]
       dist = bad_row[2]
       stu = bad_row[3]
       fix = c(sch_nm, dist, 'null', stu)
       
       print(fix)
       
       dist.table.list[lapply(dist.table.list, length)<4][[idx]] = fix
     }
   }
  
  dist.df = 
    dist.table.list %>%
    do.call(rbind.data.frame, .)
  
  if (
     mean(nrow(dist.df)) != (nrow(dist.table.ids))
   ){
     print('text table length')
     print(nrow(dist.df))
     print('id length')
     print(nrow(dist.table.ids))
  }
  
  dist.df = 
    cbind(dist.table.ids,dist.df)
  
  dist.table.columns = c(
    'map_id',
    'school_name_full',
    'dist_name_full',
    'school_city',
    'school_students'
  )
  colnames(dist.df) = dist.table.columns
  
  dist.df = 
    dist.df %>%
    mutate(
      dist_name = dist.row$name %>% tools::toTitleCase(.),
      school_level = dist.row$school_level %>% tools::toTitleCase(.),
      dist_id_full = dist.row$district_type_id,
      dist_id = dist.row$district_id,
      school_name = school_name_full %>% 
        gsub(glue('{school_level} School'), '', .) %>% trimws(.)
    )
  
  dist.columns = colnames(dist.df)
  dist.columns = c("map_id" ,dist.columns[2:length(dist.columns)] %>% sort(.))
  dist.df = dist.df[,dist.columns]
  
  return(dist.df)
}

col.districts.table = 
  col.districts.links %>%
  apply(., 1, get_table_attrs) %>%
  do.call(rbind.data.frame, .) %>%
  mutate(
    map_url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/{map_id}.geojson'))

geom_funct = function(url, map_id){
      geom =
      tryCatch(
        {
            st_read(url)$geometry
        },
        error = function(e){
            ''
        })
      # print(geom)
      # if(length(geom)>1){print(map_id)}
      return(geom)
      }

#geom_funct(col.districts.table$map_url, col.districts.table$map_id)
col.districts.geoms = 
  col.districts.table %>%
  mutate(
    geometry = 
      tryCatch(
        st_make_valid(st_read(map_url, quiet=TRUE)$geometry), 
        error = function(e) { c(e) })
  ) %>%
  st_sf(., crs=st_crs('EPSG: 4326')) %>%
  st_transform(col_crs)
col.districts.geoms$geometry

geom_list = list()
bad_list = list()
for (url in col.districts.table$map_url){

  geom_list[[url]] =
    tryCatch(st_make_valid(st_read(url, quiet=TRUE)$geometry) %>% st_union(.), 
             error = function(e) { cat('In error handler\n'); print(e); e })
  
}

check = 
  geom_list %>% map_df(as_tibble)

check$map_url = names(geom_list) %>% as.vector()

col.districts.geom = 
  col.districts.table %>% 
  merge(., check, on='map_url') %>%
  st_sf(., crs=st_crs('EPSG: 4326')) %>%
  st_transform(col_crs)

st_write(col.districts.geom, "col_school_boundary.geojson")

```



### i.8 schools


```{r plot_sfs}

# glimpse(col.districts.table)
# 
# 
# 
#   as_tibble(.,.name_repair ='minimal')
# 
# col.districts.table =
#   #col.districts.links$url %>%
#   c(col.districts.links$url[1]) %>%
#   sapply(., get_table_attrs)
# 
# 
# 
# 
# # # %>%
# #     #do.call(rbind, .) %>%
# #     as.data.frame(.)
# 
# glimpse(col.districts.table)


school.dist.scores = 
  read_csv('data/colorado_district_rankings_2021.csv') %>%
  mutate(
    GEOID = district_id %>% 
      sapply(., FUN = function(id){
        paste('08', gsub("\"", "", id), sep='')}), 
    district_id = district_id %>% 
      sapply(., FUN = function(id){gsub("\"", "", id)})) 

col.dist.polys = 
  col.districts.geom %>%
  st_transform(col_crs) %>% mutate(pre_area = st_area(geometry)) %>%
  st_intersection(., boulder.county %>% st_union()) %>%
  mutate(post_area = st_area(geometry))

attributes(col.dist.polys$pre_area) = NULL
attributes(col.dist.polys$post_area) = NULL
col.dist.polys = 
  col.dist.polys %>% 
  mutate(pct_area = post_area/ pre_area) %>%
  filter(pct_area>0.01)

boulder.dist.ele = 
  col.dist.polys %>% 
  filter(school_level == 'Elementary')

school.elementary.rank =
  read_csv('data/colorado_elementary_rankings_2020.csv') %>%
  rename(full_school_id = school_id) %>%
  mutate(
    full_school_id = full_school_id %>% 
      sapply(., FUN = function(id){gsub("\"", "", id)}),
    district_id = full_school_id %>% 
      sapply(., FUN = function(id){substr(id, 1, 4)}),
    school_id = full_school_id %>% 
      sapply(., FUN = function(id){substr(id, 7, 10)})
    ) %>% as.data.frame(.)

dist_ids = substr(school.dist.polys$GEOID, 3, 6)

school.elementary.dist = 
  school.elementary.rank[school.elementary.rank$district_id %in% dist_ids,] %>%
  mutate(
    boundary_url = 
      glue('https://s3.amazonaws.com/gm-zdm/gj/sch/sch_es_08_{district_id}_{school_id}.geojson'))


school.elementary.pts = 
  st_read('data/col_elementary_points.geojson') %>%
  st_transform(col_crs) 




ggplot() + 
  # geom_sf(
  #   data = boulder.cities, 
  #   aes(fill=incorporated), 
  #   color='transparent') + 
  geom_sf(
    data = boulder.nhoods.z, 
    aes(fill=Name), 
    color='transparent') + 
  geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
          lwd=.1, linetype = "dashed") +
  geom_sf(data = boulder.county,
          fill = 'transparent', color='black',
          lwd=1) +
  geom_text(
    data=boulder.cities.labels, check_overlap=TRUE,
    size = ifelse(boulder.cities.labels$size==2,2.5,2),
    fontface='bold', color='black',
    aes(x=lon,y=lat, label=name)) +
  theme(legend.position = "none")+ 
  mapTheme()

```

### i.A.9 Assorted Variable Creation

```{r assorted}

boulder.sales$nbrBaths =  
  boulder.sales$nbrFullBaths + boulder.sales$nbrHalfBaths

# 3. Full Bathroom
boulder.variables = add_v(
  "nbrBaths",     3,    "Internal"
)

# i. Num of Bedrooms
boulder.variables = add_v(
  "nbrBedRoom",    1,    "Internal"
)

# 2. Main Square Foot
boulder.variables = add_v(
  "mainfloorSF",   2,    "Internal"
)


# N. Nearest Neighbor
boulder.variables = add_v(
  "lagPrice",      99,   "Spatial"
)

# 3. Built Year
boulder.variables = add_v(
  "EffectiveYear",   3,    "Internal"
)

```

### i.A.10 Set Up boulder.data & 0/1 Partition

variables are one of these types:
1.	Internal characteristics (e.g. bedrooms)
2.	amenities/public services (e.g. proximity to parks)
3.	spatial structure (e.g. nearby prices)

Split up the data between sales prices known, and the sales prices that are set to 0 to be predicted 

```{r price_dataset}

ID_fields = c(
#   ID given by michael
  "MUSA_ID",
#   whether they should be predicted (1) or already have a price (0)
  "toPredict"
  )


boulder.data = boulder.sales[,c(
  ID_fields,
  boulder.variables$var_name,
  'geometry'
  )]

boulder.dv = boulder.variables[!boulder.variables$var_num %in% c(0,99), 'var_name']

boulder.predict.0 = boulder.data %>%
  filter(.,toPredict == 0)
boulder.predict.1 = boulder.data %>%
  filter(., toPredict == 1)

boulder.variables


glimpse(boulder.data)

```

