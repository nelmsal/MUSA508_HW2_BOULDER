# 2. Exploratory Data Analysis 

## A.	Table of Summary Statistics
*Present a table of summary statistics with variable descriptions.*

*Sort these variables by their category (internal characteristics, amenities/public services or spatial structure).Check out the `stargazer` package for this.*



The table below summarizes the variables that we are looking at to predict housing prices in Boulder county. These variables do not indicate causal relationship with house prices. Instead, we are investigating if the presence of these observations can correlate to  better predictions of what housing prices could be in the future. 


```{r table_predict0_vars,  results='asis'}

select_v = function(sf, variable_names=c('price', boulder.iv)){
  return(sf %>% st_drop_geometry(.) %>%
             select(variable_names))}

select_iv = function(sf, variable_names=boulder.iv){
  return(sf %>% st_drop_geometry(.) %>%
             select(variable_names))}

table_num = 1
table_title = glue("Table {table_num}: Summary Statistics for Boulder County")


stargazer(boulder.predict.0 %>% select_v(.), 
          type="text", digits=1, 
          title=table_title,
          out = "results/Boulder_Data.txt") 


```


*(this doesn't need to be in the report, but a method of filtering and transforming non-normally distributed data)*

*B. Histogram*
*Plot histograms to assess Normalcy of Data. We don't need to add this in the report, but can be part of data wrangling or feature analysis. Any that don't appear normal, look at the log transformed*
```{r histograms_predict0_vars}
fig_num = 1
variable_name = 'price'
hist(
  boulder.predict.0[[variable_name]], 
  breaks=50, 
  main=glue("Figure {fig_num}.0: {variable_name}"),
  xlab=variable_name)

for (
  variable_number in seq(1,length(boulder.iv), by=1)
){
  #plot_color = plot_colors[variable_number]
  variable_name = boulder.iv[variable_number]
  hist(
    boulder.predict.0[[variable_name]], 
    breaks=50, 
    main=glue("Figure {fig_num}.{variable_number}: {variable_name}"),
    xlab=variable_name)
  }

```


## C.	Correlation Matrix
*Present a correlation matrix*

The below figure shows a correlation matrix between the various predictor variables, highlighting which of the predictor variables present similar information. Any predictors with correlation valye greater than 0.8 means they are related to each other, and we only need to include one of them, otherwise we are repeating the same information essentially.  

```{r corr_predict0_vars}

fig_num = 2

corrPlotVariables = 
  boulder.predict.0 %>%
  select(boulder.iv) %>% st_drop_geometry(.) %>%
  select_if(., is.numeric)

ggcorrplot(
  round(cor(corrPlotVariables), 1), 
  p.mat = cor_pmat(corrPlotVariables),
  colors = c("#25CB10", "white", "#FA7800"),
  type="lower",
  insig = "blank") +  
    labs(
      title = glue("Figure {fig_num}: Boulder Housing Correlation across Numeric Variables")) 

```


## D.	Plots of Home Sales Price & 4 Independent Variables
*Present 4 home price correlation scatter plots that you think are of interest.*

*I’m going to look for interesting open data that you’ve integrated with the home sale observations*

The below are an example of three predictor variables that we are looking at to assess how well they can be used to predict boulder house sales prices. We expect to observe XXX, XXXX, and XXXX to have a positive relationship with house sales prices.   

These scatter plots also indicate whether the relationship can be predicted using a linear model, or if we need to utilize a different method for better fit. 

Talk about results of scatter plots on the variables 


```{r plot_predict0_vars}

fig_num = 3

dependent_variable = 'price'

plot_colors= c(
  "blue", "green", "red", "orange"
)

second_max = function(vector){
  vector_mx = max(vector)
  vector_cut = 
  vector[
    vector<vector_mx]
  return(max(vector_cut))
}

ylim_num = max(boulder.predict.0$price)
ylim = second_max(boulder.predict.0$price)

# price_percentiles = ecdf(boulder.predict.0$price)
# if (price_percentiles(max(boulder.predict.0$price))==1){
#   toplim=max(
#     boulder.predict.0[
#       boulder.predict.0$price < toplim,
#       'price'] %>% st_drop_geometry(.))}

for (
  variable_number in seq(1,4, by=1)
){
  plot_color = plot_colors[variable_number]
  variable_name = boulder.iv[variable_number]
  fm_equation = paste(dependent_variable, "~", variable_name, sep="")
  
  fm = as.formula(fm_equation)
  price_variable = lm(fm, data = boulder.predict.0)
  coefficient = 
    round(
      price_variable$coefficients[variable_name][1], 2)
  
  scat_plot = 
    ggplot(
      data = boulder.predict.0,
      aes(
        x = boulder.predict.0[[variable_name]],
        y = boulder.predict.0$price)) +
    geom_point(size=2, shape=20) +
    labs(title = 
           glue("Figure {fig_num}.{variable_number}: {variable_name}"),
         subtitle = glue("{fm_equation} Coefficient = {coefficient}")
         ) +
    geom_smooth(method = "lm", se=F,
                color = plot_color) +
    xlab(variable_name) +
    ylab("price") +
    ylim(min(boulder.predict.0$price), ylim) + 
    plotTheme()
  print(scat_plot)
}

```


## E.	Map of Dependent Variable (Sales Price)
*Develop 1 map of your dependent variable (sale price)*

### 1. Map Setup

```{r setup_map}


plot_limits = function(
  poly.geometry = boulder.cities$geometry,
  # buffer between plot's limits and the geometry 
  # (in unit of geometry column)
  buffer = 0
){
  # creates bounding box
  poly.bbox =
    poly.geometry %>% st_union() %>%
    # buffers the geometry so the ultimate plot has margins
    st_buffer(buffer) %>%
    st_bbox()
  return(
    # returns the 'coord_sf' function which you can add to any plot
    coord_sf(
      xlim = c(poly.bbox['xmin'], poly.bbox['xmax']),
      ylim = c(poly.bbox['ymin'], poly.bbox['ymax']),
      crs = st_crs(poly.geometry)
  ))}

get_labels = function(
  cut_breaks, round_digit = 0, bucket_diff=1, first_start_range=0, last_end_range=TRUE, input_end_range='', bucket_suffix='', bucket_prefix=''
){
  labels = 
    cut_breaks %>% gsub(",", " to ", .) %>% 
    str_sub(., 2, -2) %>% unique(.)
  
  list_str = function(l, remove=0){
      format(round(as.numeric(l), digit=round_digit)-remove, big.mark=",")}
  
  for (i in seq(from=1,to=length(labels))){
    bucket_range = labels[i] %>% str_split(., " to ")
    
    start_range = paste(bucket_prefix, list_str(bucket_range[[1]][1]))
    end_range = paste(list_str(bucket_range[[1]][2], remove=bucket_diff), bucket_suffix)
    
    if (i == 1 & first_start_range != ''){
      start_range = paste(bucket_prefix, list_str(first_start_range))}
    if (i == length(labels) & input_end_range!=''){
      end_range=paste(list_str(input_end_range), bucket_suffix)
      last_end_range=TRUE
      }
    if (i == length(labels) & last_end_range==FALSE){end_range='+'}
    
    bucket = paste(
        start_range, 
        'to', 
        end_range) %>% str_trim()
    labels[i] = bucket}
    
  return(labels)
  }



plot_vari_spec = function(
  focus_sf  = boulder.predict.0,
  variable  = "price",
  qbreaks   = q5(boulder.predict.0, "price"),
  bucket_diff = 1,
  title     = "Housing Price Variable", 
  subtitle  = "",
  legend_nm = "price",
  caption   = "",
  brewer_colors = 'Spectral',
  round_digit = 0,
  last_end_range = TRUE,
  input_end_range = '',
  bucket_suffix = '',
  buff_col = 'red',
  col_rev = FALSE,
  first_start_range = 0
){

cutting_field = function(var_field, var_breaks){return(var_field %>% cut(., breaks = var_breaks, dig.lab=10, include.lowest = TRUE))}

focus_sf$cut_field = cutting_field(focus_sf[[variable]], qbreaks)
  
cut_breaks = sapply(focus_sf$cut_field, function(brk) brk %>% levels())

labels = get_labels(
  cut_breaks, 
  round_digit = round_digit, bucket_diff = bucket_diff, 
  last_end_range = last_end_range, first_start_range = first_start_range, 
  input_end_range = input_end_range, bucket_suffix = bucket_suffix)

breaks_amount = length(qbreaks)-1
col_vals = brewer.pal(breaks_amount, name = brewer_colors)

if (col_rev==TRUE){col_vals=rev(col_vals)}

return(
ggplot()+
  # geom_sf(data = EB.all, fill=alpha('grey50', .5), color=alpha('grey50', .5)) + 
  # geom_sf(data = EB.back_water, fill=alpha('cornflowerblue', .5), color='transparent') + 
  # geom_sf(data  = EB.cities, fill='grey90')+
  geom_sf(
    data  = focus_sf, 
    aes(fill = cut_field), 
    color='grey50') +
  scale_fill_manual(
    values = col_vals,
    labels = labels, name = legend_nm) +
  # geom_sf(
  #   data=BART.buffers.TOD, fill='transparent', 
  #   color=alpha(buff_col, alpha=.75), lwd=.75) +
  # geom_sf(
  #   data=BART.stops, fill='white',
  #   color='grey30', shape=21) + 
  # geom_text(
  #   data=EB.labels, check_overlap=TRUE,
  #   size = 3.5, fontface='bold', color='black',
  #   aes(x=lon,y=lat, label=label)) + 
  labs(title    = title, 
       subtitle = subtitle,
       caption  = caption) +
  guides(fill = guide_legend(title.position="bottom", 
                             title.hjust = 0.5, title.vjust = 0)) + 
  theme(legend.position = "bottom",
        legend.spacing.x = unit(.1, 'in')) +
  # facet_wrap(~year)+
  mapTheme() #+ plot_limits()
)}

################
```


### 2. Map of Dependent Variable - Housing Prices 

Further to looking at the linear relationship between the variables, we also examine the spatial location and visual patterns between the predictor variables and house sales price through several maps. 

The map below shows the spatial distribution of house sales prices through Boulder County. 
```{r map_predict0_dv}

fig_num = 4

sub_fig_num = 0

variable  = "price"

filt_sf = 
  boulder.predict.0[
    !is.na(boulder.predict.0[[variable]]) &
      !is.infinite(boulder.predict.0[[variable]])
                       ,]
max_variable = max(filt_sf[[variable]])

#breaks = c(0,25,50,100, 150, max_variable)
breaks = seq(0, max_variable, length.out = 5)

plot_vari_spec(
  focus_sf  = filt_sf,
  variable  = variable,
  qbreaks   = breaks,
  title     = glue("Figure {fig_num}.{sub_fig_num} Home Prices"), 
  subtitle  = "",
  caption   = "",
  brewer_colors = 'OrRd',
  legend_nm = "Home Price",
  bucket_suffix = '  ',
  input_end_range = '',
  last_end_range = FALSE,
  round_digit=0,
  bucket_diff=1,
  first_start_range=0
)


# ggplot() +
#   # geom_sf(data = boulder.predict.0, 
#   #         fill = "gray80", color = "white") +
#   # geom_sf(data = boulder.predict.0, 
#   #         fill = "XXXXX", color = "XXXXXX") +
#   geom_sf(data = boulder.predict.0, 
#           aes(color = q5(price))) +
#   scale_color_manual(values = paletteMap) +
#   labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
#   mapTheme()


```


## F.	Maps of 3 Independent Variables
*Develop 3 maps of 3 of your most interesting independent variables.*


Next, we look at the spatial features of the the variables XXXX, XXXX, XXXX and XXXX.  Comment on where they look on the map, how its ditributed. 



```{r map_predict0_iv}

#maybe we can insert faded base map of boulder county?



for (
  variable_number in seq(1,3, by=1)
){
  plot_color = plot_colors[variable_number]
  variable_name = boulder.iv[variable_number]
  
  fm = 
  as.formula(paste(
    'price', "~", variable_name, sep=""))
  price_variable = lm(fm, data = boulder.predict.0)
  coefficient = 
    round(
      price_variable$coefficients[variable_name][1], 2)
  
  scat_plot = 
    ggplot(
      data = boulder.predict.0,
      aes(
        x = boulder.predict.0[[variable_name]],
        y = boulder.predict.0$price)) +
    geom_point(size=2, shape=20) +
    labs(title = 
           glue("Figure 2.{variable_number}: {variable_name}"),
         subtitle = glue("Coefficient = {coefficient}")
         ) +
    geom_smooth(method = "lm", se=F,
                color = plot_color) +
    xlab(variable_name) +
    ylab("price") +
    ylim(min(boulder.predict.0$price), ylim) + 
    plotTheme()
  print(scat_plot)
  
  variable_map = 
    ggplot() +
    geom_sf(
      data = boulder.predict.0, 
      aes(color =
        q5(boulder.predict.0[[variable_name]]))) +
    scale_color_manual(values = paletteMap) +
    labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
    mapTheme()
  print(variable_map)
}

# #variable 1
# ggplot() +
#   geom_sf(data = XXXX, fill = "gray80", color = "white") +
#   geom_sf(data = XXXX, fill = "XXXXX", color = "XXXXXX") +
#   geom_sf(data = boulder.predict.0, aes(color = q5(XXXXXX))) +
#   scale_color_manual(values = paletteMap) +
#   labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
#   mapTheme()
# 
# #variable 2
# ggplot() +
#   geom_sf(data = XXXX, fill = "gray80", color = "white") +
#   geom_sf(data = XXXX, fill = "XXXXX", color = "XXXXXX") +
#   geom_sf(data = boulder.predict.0, aes(color = q5(XXXXX))) +
#   scale_color_manual(values = paletteMap) +
#   labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
#   mapTheme()
# 
# #variable 3
# ggplot() +
#   geom_sf(data = XXXX, fill = "gray80", color = "white") +
#   geom_sf(data = XXXX, fill = "XXXXX", color = "XXXXXX") +
#   geom_sf(data = boulder.predict.0, aes(color = q5(XXXX))) +
#   scale_color_manual(values = paletteMap) +
#   labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
#   mapTheme()
# 
# #variable 4
# ggplot() +
#   geom_sf(data = XXXX, fill = "gray80", color = "white") +
#   geom_sf(data = XXXX, fill = "XXXXX", color = "XXXXXX") +
#   geom_sf(data = boulder.predict.0, aes(color = q5(XXXXX))) +
#   scale_color_manual(values = paletteMap) +
#   labs(title = "XXXXXXXX", subtitle = "XXXXXXX") +
#   mapTheme()


```

## G. Assorted Figures
*Include any other maps/graphs/charts you think might be of interest.*


-------------------------------