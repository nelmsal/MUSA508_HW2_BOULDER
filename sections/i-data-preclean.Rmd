# i. Data
## i.A Gathering Data
*Briefly describe your methods for gathering the data.*

### i.A.1 Import Data
```{r import}

col_crs = st_crs('ESRI:102653')


```

### i.A.2 Parcel Joins


```{r parcel}

parcel_path =
  "data/Boulder_Parcels_20211009.geojson"
boulder.parcel = st_read(parcel_path) %>%
  rename(ID = OBJECTID, APN=PARCEL_NO) %>%
  select(ID,APN) %>%
  st_transform(., col_crs) %>% # North Col State Plane Feet
  mutate(
    geometry = st_make_valid(geometry),
    area = st_area(geometry))
attributes(boulder.parcel$area) = NULL
boulder.parcel = boulder.parcel %>% filter(area>0)

# address_path =
#   "data/Boulder_AddressPts_20211009.geojson"
# boulder.address = st_read(address_path)%>%
#   st_transform(., col_crs)
# 
# acct_path =
#   "data/Account_Parcels.csv"
# boulder.parcel.acct = read.csv(acct_path)
# 
# build_path =
#   "data/Buildings.csv"
# boulder.parcel.build = read.csv(build_path)
# 
# land_path =
#   "data/Land.csv"
# boulder.parcel.land = read.csv(land_path)
# 
# owner_path =
#   "data/Owner_Address.csv"
# boulder.parcel.owner = read.csv(owner_path)
# 
# permits =
#   "data/Permits.csv"
# B.build = read.csv(build_path)

```

### i.A.3 Parcel Clean

```{r parcel_clean}

OG_len = nrow(boulder.parcel%>% st_drop_geometry())
APN_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., APN))
ID_len = nrow(boulder.parcel %>% st_drop_geometry() %>% distinct(., ID, APN))
area_len = nrow(boulder.parcel[boulder.parcel$area>0,] %>% st_drop_geometry() )

print(OG_len)
print(OG_len-APN_len)
print(OG_len-ID_len)
print(OG_len-area_len)

# boulder.parcel[(boulder.parcel$area<=0)&(boulder.parcel$APN %in% dupe_APN),]

n_occur =
  data.frame(table(boulder.parcel$APN)) %>%
  rename(APN=Var1) %>% arrange(-Freq)

dupe_APN = n_occur[n_occur$Freq > 1,"APN"]
B.dupe =
  boulder.parcel[boulder.parcel$APN %in% dupe_APN,] %>% group_by(APN) %>%
  summarize(geometry = st_union(geometry))

boulder.parcel[(boulder.parcel$APN == "157505036006")&
        (boulder.parcel$area>0),]

boulder.county = boulder.parcel %>% st_union(.)

ggplot() +
  geom_sf(data=boulder.county, lwd=.1, color='lightgrey') 
+
  geom_sf(data=boulder.parcel, lwd=.1) +
  geom_sf(data=B.dupe,
          fill='pink', color='red') +
  plot_limits(poly.geometry= B.dupe)
```


### i.5 boundaries 

```{r bound}

# CREATE ERASE FUNCTION
st_erase <- function(x, y) {
  st_difference(x, st_union(y))}

state.cities = 
  st_read('data/col_city_boundaries.geojson') %>%
  st_transform(., col_crs) %>%
  rename(
    name = NAME10,
    name_long = NAMELSAD10
  ) %>% 
  mutate(incorporated = 
          ifelse(grepl('city', name_long), 'city',
                 ifelse(grepl('town', name_long), 'town',
                        ifelse(grepl('CDP', name_long), 'CDP',
                               'TRUE'))))
state.counties = 
  st_read('data/col_county_boundaries.geojson') %>%
  st_transform(., col_crs)


state.bound = 
  st_read('data/col_state_boundary.geojson') %>%
  st_transform(., col_crs)

state.cities = 
  state.counties %>% select(LABEL, FULL, geometry) %>%
      rename(name = LABEL, name_long = FULL) %>% 
      mutate(
        name_long = paste('Unincorporated', name_long, sep=" "),
        name = paste(name, 'County', sep=" "),
        incorporated = 'County'
        ) %>%
  st_erase(.,
    state.cities) %>% select(name, name_long, incorporated, geometry) %>%
  rbind(
    .,
    state.cities %>% select(name, name_long, incorporated, geometry)) %>%
  st_sf() %>%
  mutate(first_area = st_area(geometry))

attributes(state.cities$first_area) = NULL


boulder.county = state.counties %>% filter(COUNTY=="BOULDER")
boulder.cities = 
  st_intersection(
    state.cities, 
    boulder.county %>% st_union()) %>%
  mutate(land_area = st_area(geometry)) %>%
  filter((incorporated!='County')|grepl('Boulder', name_long))

attributes(boulder.cities$land_area) = NULL

boulder.cities = 
  boulder.cities %>%
  mutate(pct_bould = land_area/first_area) %>%
  filter(pct_bould<=0.1) %>% select(-pct_bould)

boulder.cities.labels = 
  boulder.cities %>%
  st_centroid(., of_largest_polygon = TRUE) %>% 
  filter((incorporated!='County')) %>%
  mutate(
    lon = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[1]]),
    lat = map_dbl(geometry, 
                  ~st_centroid(.x, of_largest_polygon = TRUE)[[2]]),
    size = 
          ifelse(grepl('city', name_long), 2,
                 ifelse(grepl('town', name_long), 1.5,
                        ifelse(grepl('CDP', name_long), 0,
                               0)))) %>% 
  filter(size>0)

second_max = function(vector){
  vector_mx = max(vector)
  vector_cut = 
  vector[
    vector<vector_mx]
  return(max(vector_cut))
}

hist(boulder.cities$land_area[
  boulder.cities$land_area<max(boulder.cities$land_area)], 
     xlim=c(0, second_max(boulder.cities$land_area)), breaks=50)

ggplot() + 
  geom_sf(
    data = boulder.cities, 
    aes(fill=incorporated), 
    color='transparent') + 
  geom_sf(data = boulder.cities, fill = 'transparent', color='grey',
          lwd=.1, linetype = "dashed") + 
  geom_sf(data = boulder.county, fill = 'transparent', color='black',
          lwd=1) + 
  geom_text(
    data=boulder.cities.labels, check_overlap=TRUE,
    size = ifelse(boulder.cities.labels$size==2,2.5,2), 
    fontface='bold', color='black',
    aes(x=lon,y=lat, label=name)) + mapTheme()

```


### i.8 schools


```{r plot_sfs}

school_districts_api = 'https://opendata.arcgis.com/datasets/b552828530424726b144bf9b39b417cc_1.geojson'

school_districts_scores = 


```

### i.A.9 Assorted Variable Creation

```{r assorted}

boulder.sales$nbrBaths =  
  boulder.sales$nbrFullBaths + boulder.sales$nbrHalfBaths

# 3. Full Bathroom
boulder.variables = add_v(
  "nbrBaths",     3,    "Internal"
)

# i. Num of Bedrooms
boulder.variables = add_v(
  "nbrBedRoom",    1,    "Internal"
)

# 2. Main Square Foot
boulder.variables = add_v(
  "mainfloorSF",   2,    "Internal"
)


# N. Nearest Neighbor
boulder.variables = add_v(
  "lagPrice",      99,   "Spatial"
)

# 3. Built Year
boulder.variables = add_v(
  "EffectiveYear",   3,    "Internal"
)

```

### i.A.10 Set Up boulder.data & 0/1 Partition

variables are one of these types:
1.	Internal characteristics (e.g. bedrooms)
2.	amenities/public services (e.g. proximity to parks)
3.	spatial structure (e.g. nearby prices)

Split up the data between sales prices known, and the sales prices that are set to 0 to be predicted 

```{r price_dataset}

ID_fields = c(
#   ID given by michael
  "MUSA_ID",
#   whether they should be predicted (1) or already have a price (0)
  "toPredict"
  )


boulder.data = boulder.sales[,c(
  ID_fields,
  boulder.variables$var_name,
  'geometry'
  )]

boulder.dv = boulder.variables[!boulder.variables$var_num %in% c(0,99), 'var_name']

boulder.predict.0 <- boulder.data %>%
  filter(.,toPredict == 0)
boulder.predict.1 <- boulder.data %>%
  filter(., toPredict == 1)

boulder.variables


glimpse(boulder.data)

```

